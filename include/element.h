/*!
*  \file    element.h
*  \author  Caleb Amoa Buahin <caleb.buahin@gmail.com>
*  \version 1.0.0
*  \section Description
*  This file and its associated files and libraries are free software;
*  you can redistribute it and/or modify it under the terms of the
*  Lesser GNU General Public License as published by the Free Software Foundation;
*  either version 3 of the License, or (at your option) any later version.
*  fvhmcompopnent.h its associated files is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.(see <http://www.gnu.org/licenses/> for details)
*  \date 2018
*  \pre
*  \bug
*  \todo Test transport on branching networks
*  \warning
*/

#ifndef ELEMENT_H
#define ELEMENT_H


#include "variable.h"
#include "stmcomponent_global.h"

#include <string>

struct Element;
struct ElementJunction;
class STMModel;

/*!
 *\brief Function pointer to calculate temperature advection to eliminate costly if else function calls
 */
typedef double (Element::*ComputeTempAdv)(double dt, double T[]);

/*!
 *\brief Function pointer to calculate solute advection to eliminate costly if else function calls
 */
typedef double (Element::*ComputeSoluteAdv)(double dt, double S[], int soluteIndex);

/*!
 * \brief This struct represents the channel control volume
 */
struct  STMCOMPONENT_EXPORT Element
{
    /*!
    * \brief Element - Creates an instance of the control volume element used to represent a computational
    * element in a reach.
    * \param numSolutes - Number of solutes that are going to be transported in addition to temperature.
    * \param from - The upstream junction of this element.
    * \param to - The downstream junction of this element.
    * \param project
    */
   Element(const std::string &id, ElementJunction *upstream, ElementJunction *downstream,  STMModel *model);

   /*!
    * \brief ~Element - Destructor for this class.
    */
   ~Element();

   /*!
    * \brief index unique identifier for element
    */
   int index;

   /*!
    * \brief id
    */
   std::string id;

   /*!
    * \brief x
    */
   double x;

   /*!
    * \brief y
    */
   double y;

   /*!
    * \brief z
    */
   double z;

   /*!
    * \brief temperature
    */
   Variable temperature;

   /*!
    * \brief prevTemperature
    */
   Variable prevTemperature;

   /*!
    * \brief numSolutes
    */
   int numSolutes = 0;

   /*!
    * \brief soluteConcs
    */
   Variable *soluteConcs;

   /*!
    * \brief prevSoluteConcs
    */
   Variable *prevSoluteConcs;

   /*!
    * \brief longDispersion
    */
   Variable longDispersion;

   /*!
    * \brief fromJunction
    */
   ElementJunction *upstreamJunction;

   /*!
    * \brief toJunction
    */
   ElementJunction *downstreamJunction;

   /*!
    * \brief length
    */
   double length;

   /*!
    * \brief depth
    */
   double depth;

   /*!
    * \brief xSectionArea
    */
   double xSectionArea;

   /*!
    * \brief width
    */
   double width;

   /*!
    * \brief flow
    */
   double flow;

   /*!
    * \brief slope
    */
   double slope;

   /*!
    * \brief externalHeatFluxes of J / s
    */
   double externalHeatFluxes;

   /*!
    * \brief externalSoluteFluxes W/m^2
    */
   double radiationFluxes;

   /*!
    * \brief externalSoluteFluxes of the form kg / s
    */
   double *externalSoluteFluxes;

   /*!
    * \brief heatBalance
    */
   double heatBalance;

   /*!
    * \brief soluteMassBalance
    */
   double *soluteMassBalance;

   /*!
    * \brief pecletNumber
    */
   double pecletNumber;

   /*!
    * \brief upstreamElement
    */
   Element *upstreamElement;

   /*!
    * \brief upstreamElementDirection
    */
   double upstreamElementDirection;

   /*!
    * \brief downstreamElement
    */
   Element *downstreamElement;

   /*!
    * \brief downstreamElementDirection
    */
   double downstreamElementDirection;

   /*!
    * \brief model
    */
   STMModel *model;

   /*!
    * \brief initializeSolutes
    * \param numSolutes
    */
   void initialize();

   /*!
    * \brief initializeSolutes
    */
   void initializeSolutes();

   /*!
    * \brief computeDTDt - Computes the time derivative of temperature based on data generated by the ODE solver.
    * \param dt - The timestep over which to compute the solute gradient.
    * \param T - The temperature array for all elements.
    * \return
    */
   double computeDTDt(double dt, double T[]);

   /*!
    * \brief computeDTDtDispersion
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtDispersion(double dt, double T[]);

   /*!
    * \brief computeDTDtUpwind
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtUpwind(double dt, double T[]);

   /*!
    * \brief computeDTDtCentral
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtCentral(double dt, double T[]);

   /*!
    * \brief computeDTDtHybrid
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtHybrid(double dt, double T[]);

   /*!
    * \brief computeDTDtUltimate
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtTVD(double dt, double T[]);

   /*!
    * \brief computeDSoluteDt
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDt(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtDispersion
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtDispersion(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtUpwind
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtUpwind(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtCentral
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtCentral(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtHybrid
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtHybrid(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtENO
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtTVD(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeCourantNumber
    * \return
    */
   double computeCourantFactor() const;

   /*!
    * \brief commputeDispersionFactor
    * \return
    */
   double computeDispersionFactor() const;

   /*!
    * \brief computeLongDispersion
    */
   void computeLongDispersion();

   /*!
    * \brief computePecletNumbers
    */
   void computePecletNumbers();

   /*!
    * \brief calculateUpstreamPeclet
    */
   void computeUpstreamPeclet();

   /*!
    * \brief calculateDownstreamPeclet
    */
   void computeDownstreamPeclet();

   /*!
    * \brief computeHeatBalance
    */
   void computeHeatBalance();

   /*!
    * \brief computeSoluteBalance
    * \param soluteIndex
    */
   void computeSoluteBalance(int soluteIndex);

  private:

   /*!
    * \brief setUpstreamElement
    */
   void setUpstreamElement();

   /*!
    * \brief setDownStreamElement
    */
   void setDownStreamElement();

   /*!
    * \brief computeUpstreamFlow
    */
   void computeUpstreamFlow();

   /*!
    * \brief computeDownstreamFlow
    */
   void computeDownstreamFlow();

   /*!
    * \brief downStreamPecletNumber
    */
   double downstreamPecletNumber;

   /*!
    * \brief downstreamFlow
    */
   double downstreamFlow;

   /*!
    * \brief downstreamVelocity
    */
   double downstreamVelocity;

   /*!
    * \brief upStreamPecletNumber
    */
   double upstreamPecletNumber;

   /*!
    * \brief upstreamFlow
    */
   double upstreamFlow;

   /*!
    * \brief upstreamVelocity
    */
   double upstreamVelocity;

   /*!
    * \brief computeTempAdv Pointer to function to compute temperature advection.
    */
   ComputeTempAdv computeTempAdv;

   /*!
    * \brief computeSoluteAdv Pointer to function to compute solute advection.
    */
   ComputeSoluteAdv computeSoluteAdv;

};

#endif // ELEMENT_H
