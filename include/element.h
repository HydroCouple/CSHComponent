#ifndef ELEMENT_H
#define ELEMENT_H

#include <string>

#include "variable.h"

struct Element;
struct ElementJunction;
class STMModel;

/*!
 *\brief Function pointer to calculate temperature advection to eliminate costly if else function calls
 */
typedef double (Element::*ComputeTempAdv)(double dt, double T[]);

/*!
 *\brief Function pointer to calculate solute advection to eliminate costly if else function calls
 */
typedef double (Element::*ComputeSoluteAdv)(double dt, double S[], int soluteIndex);

/*!
 * \brief This struct represents the channel control volume
 */
struct Element
{
    /*!
    * \brief Element - Creates an instance of the control volume element used to represent a computational
    * element in a reach.
    * \param numSolutes - Number of solutes that are going to be transported in addition to temperature.
    * \param from - The upstream junction of this element.
    * \param to - The downstream junction of this element.
    * \param project
    */
   Element(const std::string &id, ElementJunction *upstream, ElementJunction *downstream,  STMModel *model);

   /*!
    * \brief ~Element - Destructor for this class.
    */
   ~Element();

   /*!
    * \brief index unique identifier for element
    */
   int index;

   /*!
    * \brief id
    */
   std::string id;

   /*!
    * \brief x
    */
   double x;

   /*!
    * \brief y
    */
   double y;

   /*!
    * \brief z
    */
   double z;

   /*!
    * \brief temperature
    */
   Variable temperature;

   /*!
    * \brief prevTemperature
    */
   Variable prevTemperature;

   //   /*!
   //    * \brief DTDx
   //    */
   //   Variable DTDx;

   /*!
    * \brief numSolutes
    */
   int numSolutes = 0;

   /*!
    * \brief soluteConcs
    */
   Variable *soluteConcs;

   /*!
    * \brief prevSoluteConcs
    */
   Variable *prevSoluteConcs;

   /*!
    * \brief longDispersion
    */
   Variable longDispersion;

   /*!
    * \brief fromJunction
    */
   ElementJunction *upstreamJunction;

   /*!
    * \brief toJunction
    */
   ElementJunction *downstreamJunction;

   /*!
    * \brief length
    */
   double length;

   /*!
    * \brief depth
    */
   double depth;

   /*!
    * \brief xSectionArea
    */
   double xSectionArea;

   /*!
    * \brief width
    */
   double width;

   /*!
    * \brief flow
    */
   double flow;

   /*!
    * \brief slope
    */
   double slope;

   /*!
    * \brief externalHeatFluxes of J / s
    */
   double externalHeatFluxes;

   /*!
    * \brief externalSoluteFluxes W/m^2
    */
   double radiationFluxes;

   /*!
    * \brief externalSoluteFluxes of the form m^3. C / s
    */
   double *externalSoluteFluxes;

   /*!
    * \brief pecletNumber
    */
   double pecletNumber;

   /*!
    * \brief upstreamElement
    */
   Element *upstreamElement;

   /*!
    * \brief upstreamElementDirection
    */
   double upstreamElementDirection;

   /*!
    * \brief downstreamElement
    */
   Element *downstreamElement;

   /*!
    * \brief downstreamElementDirection
    */
   double downstreamElementDirection;

   /*!
    * \brief model
    */
   STMModel *model;

   /*!
    * \brief initializeSolutes
    * \param numSolutes
    */
   void initialize();

   /*!
    * \brief initializeSolutes
    */
   void initializeSolutes();

   /*!
    * \brief computeDTDt - Computes the time derivative of temperature based on data generated by the ODE solver.
    * \param dt - The timestep over which to compute the solute gradient.
    * \param T - The temperature array for all elements.
    * \return
    */
   double computeDTDt(double dt, double T[]);

   /*!
    * \brief computeDTDtDispersion
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtDispersion(double dt, double T[]);

   /*!
    * \brief computeDTDtUpwind
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtUpwind(double dt, double T[]);

   /*!
    * \brief computeDTDtCentral
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtCentral(double dt, double T[]);

   /*!
    * \brief computeDTDtHybrid
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtHybrid(double dt, double T[]);

   /*!
    * \brief computeDTDtUltimate
    * \param dt
    * \param T
    * \return
    */
   double computeDTDtTVD(double dt, double T[]);

   /*!
    * \brief computeDSoluteDt
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDt(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtDispersion
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtDispersion(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtUpwind
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtUpwind(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtCentral
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtCentral(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeDSoluteDtHybrid
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtHybrid(double dt, double S[], int soluteIndex);


   /*!
    * \brief computeDSoluteDtENO
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDtTVD(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeCourantNumber
    * \return
    */
   double computeCourantFactor() const;

   /*!
    * \brief commputeDispersionFactor
    * \return
    */
   double computeDispersionFactor() const;

   /*!
    * \brief computeLongDispersion
    */
   void computeLongDispersion();

   /*!
    * \brief computePecletNumbers
    */
   void computePecletNumbers();

   /*!
    * \brief calculateUpstreamPeclet
    */
   void computeUpstreamPeclet();

   /*!
    * \brief calculateDownstreamPeclet
    */
   void computeDownstreamPeclet();

  private:

   /*!
    * \brief setUpstreamElement
    */
   void setUpstreamElement();

   /*!
    * \brief setDownStreamElement
    */
   void setDownStreamElement();

   /*!
    * \brief computeUpstreamFlow
    */
   void computeUpstreamFlow();

   /*!
    * \brief computeDownstreamFlow
    */
   void computeDownstreamFlow();

   /*!
    * \brief downStreamPecletNumber
    */
   double downstreamPecletNumber;

   /*!
    * \brief downstreamFlow
    */
   double downstreamFlow;

   /*!
    * \brief downstreamVelocity
    */
   double downstreamVelocity;

   /*!
    * \brief upStreamPecletNumber
    */
   double upstreamPecletNumber;

   /*!
    * \brief upstreamFlow
    */
   double upstreamFlow;

   /*!
    * \brief upstreamVelocity
    */
   double upstreamVelocity;

   /*!
    * \brief computeTempAdv Pointer to function to compute temperature advection.
    */
   ComputeTempAdv computeTempAdv;

   /*!
    * \brief computeSoluteAdv Pointer to function to compute solute advection.
    */
   ComputeSoluteAdv computeSoluteAdv;

};

#endif // ELEMENT_H
