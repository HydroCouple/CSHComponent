#ifndef ELEMENT_H
#define ELEMENT_H

#include <string>

#include "variable.h"


struct ElementJunction;
class STMModel;

/*!
 * \brief This struct represents the channel control volume
 */
struct Element
{
    /*!
    * \brief Element - Creates an instance of the control volume element used to represent a computational
    * element in a reach.
    * \param numSolutes - Number of solutes that are going to be transported in addition to temperature.
    * \param from - The upstream junction of this element.
    * \param to - The downstream junction of this element.
    * \param project
    */
   Element(const std::string &id, ElementJunction *upstream, ElementJunction *downstream,  STMModel *model);

   /*!
    * \brief ~Element - Destructor for this class.
    */
   ~Element();

   /*!
    * \brief index unique identifier for element
    */
   int index;

   /*!
    * \brief id
    */
   std::string id;

   /*!
    * \brief numSolutes
    */
   int numSolutes;

   /*!
    * \brief temperature
    */
   Variable temperature;

   /*!
    * \brief prevTemperature
    */
   Variable prevTemperature;

   /*!
    * \brief DTDx
    */
   Variable DTDx;

   /*!
    * \brief soluteConcs
    */
   Variable *soluteConcs;

   /*!
    * \brief prevSoluteConcs
    */
   Variable *prevSoluteConcs;

   /*!
    * \brief longDispersion
    */
   Variable longDispersion;

   /*!
    * \brief fromJunction
    */
   ElementJunction *upstreamJunction;

   /*!
    * \brief toJunction
    */
   ElementJunction *downstreamJunction;

   /*!
    * \brief length
    */
   double length;

   /*!
    * \brief depth
    */
   double depth;

   /*!
    * \brief xSectionArea
    */
   double xSectionArea;

   /*!
    * \brief width
    */
   double width;

   /*!
    * \brief flow
    */
   double flow;

   /*!
    * \brief slope
    */
   double slope = 0.000001;

   /*!
    * \brief externalHeatFluxes of J / s
    */
   double externalHeatFluxes;

   /*!
    * \brief externalSoluteFluxes W/m^2
    */
   double radiationFluxes;

   /*!
    * \brief externalSoluteFluxes of the form m^3. C / s
    */
   double *externalSoluteFluxes;

   /*!
    * \brief pecletNumber
    */
   double pecletNumber;

   Element *upstreamElement;

   double upstreamElementDirection;

   Element *downstreamElement;

   double downstreamElementDirection;

   /*!
    * \brief model
    */
   STMModel *model;

   /*!
    * \brief initializeSolutes
    * \param numSolutes
    */
   void initializeSolutes(int numSolutes);

   /*!
    * \brief setUpstreamElement
    */
   void setUpstreamElement();

   /*!
    * \brief setDownStreamElement
    */
   void setDownStreamElement();

   /*!
    * \brief computeDTDt - Computes the time derivative of temperature based on actual element values.
    * \param dt - The timestep over which to compute the gradient.
    * \return Returns the temperature time derivative.
    */
   double computeDTDt(double dt);

   /*!
    * \brief computeDSoluteDt - Computes the solute time derivative.
    * \param dt - The timestep over which to compute the solute gradient.
    * \param soluteIndex - The index for the solute.
    * \return Returns the value of the solute time derivative.
    */
   double computeDSoluteDt(double dt, int soluteIndex);

   /*!
    * \brief computeDTDt - Computes the time derivative of temperature based on data generated by the ODE solver.
    * \param dt - The timestep over which to compute the solute gradient.
    * \param T - The temperature array for all elements.
    * \return
    */
   double computeDTDt(double dt, double T[]);

   /*!
    * \brief computeDSoluteDt
    * \param dt
    * \param S
    * \param soluteIndex
    * \return
    */
   double computeDSoluteDt(double dt, double S[], int soluteIndex);

   /*!
    * \brief computeCourantNumber
    * \return
    */
   double computeCourantFactor() const;

   /*!
    * \brief computeLongDispersion
    */
   void computeLongDispersion();

   /*!
    * \brief computePecletNumbers
    */
   void computePecletNumbers();

   /*!
    * \brief calculateUpstreamPeclet
    */
   void computeUpstreamPeclet();

   /*!
    * \brief calculateDownstreamPeclet
    */
   void computeDownstreamPeclet();

  private:

   void computeUpstreamFlow();

   void computeDownstreamFlow();

   /*!
    * \brief downStreamPecletNumber
    */
   double downstreamPecletNumber;

   double downstreamFlow;

   double downstreamVelocity;

   /*!
    * \brief upStreamPecletNumber
    */
   double upstreamPecletNumber;

   double upstreamFlow;

   double upstreamVelocity;


};

#endif // ELEMENT_H
